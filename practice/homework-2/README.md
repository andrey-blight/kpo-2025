# Контрольная работа 1

# Приложения для банковского учета вакансий

## Структура

Главными классами являются фасады в которых реализована вся API взаимодействия пользователя со структурой и базой данных

Фасады внутри себя создают нужную команду (используя для этого фабрику команд). Так же любую команду в фасаде можно
запустить с флагом with_runtime, и в таком случае в консоль выведется время исполнения команды

Команды, используя сервис того или иного компонента выполняют бизнес логику

Так же подключена ORM и DI контейнеры

## GoF, SOLID и GRASP

### Принципы SOLID

Проект следует SOLID принципам:

1. S (Single Responsibility Principle) – каждый класс выполняет одну конкретную задачу:
   
   • CommandFactory отвечает за создание команд.
   
   • Facades дают API пользователям.

   • Services реализуют бизнес логику.

   • Entities хранят структуру таблицы в схеме бд.
2. O (Open/Closed Principle) – легко добавлять новых сущности и функционал, не изменяя существующий код. Нужно просто
   добавить Facade класс для User API и реализовать команды для этого API
3. L (Liskov Substitution Principle) – программы, использующие базовые классы, должны иметь возможность использовать их
   подклассы без изменения поведения.

   • Все команды наследуются от общего интерфейса Command, поэтому любой новый тип команды можно использовать в
      CommandFactory, не меняя его логику.

   • Фасады зависят от абстрактного интерфейса команд, а не от конкретных реализаций.
4. I (Interface Segregation Principle) – не стоит заставлять классы реализовывать методы, которые они не используют.

   • В проекте интерфейсы разбиты по ролям:

   • Command – общий интерфейс для команд.

   • ResultCommand<T> – интерфейс для команд, возвращающих результат.

   • Это позволяет избежать ненужных методов в конкретных реализациях команд.

5. D (Dependency Inversion Principle) – Spring внедряет зависимости через @Component и @Autowired.

### Принципы GRASp

1. Information Expert (Эксперт по информации) - ответственность за обработку данных должна лежать на классе, который
   имеет всю необходимую информацию для выполнения этой работы.

   • Services (CategoryService) — это примеры таких классов, так как они выполняют бизнес-логику и обрабатывают данные,
   хранящиеся в базе данных.
2. Creator (Создатель) - объект должен быть ответственен за создание объектов, с которыми он сильно связан.

   • CommandFactory — пример создания команд с использованием фабрики. Команды создаются через
   фабричный метод, что позволяет избежать жёсткой связи классов с конкретными реализациями команд.
3. Controller (Контроллер) - ответственны за управление пользователем или событием, управляя выполнением системы.

   • Facade играет роль контроллера. Он отвечает за координацию взаимодействия с пользователем и
   вызывает соответствующие команды, делая API более удобным для пользователей.
4. Low Coupling (Низкая связность) - классы и компоненты системы должны быть слабо связаны, чтобы изменения в одном
   компоненте не оказывали большого влияния на другие.

   • В проекте используется Spring Dependency Injection для внедрения зависимостей, что способствует низкой связности
   между компонентами.
5. High Cohesion (Высокая связность) - класс должен быть ответственен за узкую область задач, имея высокую степень
   связности внутри своего контекста.

   • В проекте Command и Service классы имеют высокую связность, так как каждый из них отвечает за строго определённую
   задачу. Command выполняет операции, а Service решает конкретные бизнес-задачи.
6. Polymorphism (Полиморфизм) - объекты могут быть обработаны через общий интерфейс, позволяя использовать их
   взаимозаменяемо.

   • Command и ResultCommand<T> реализуют полиморфизм. Обе команды реализуют общий интерфейс Command, и они
   могут быть использованы в фасаде без учета их конкретных реализаций, что позволяет легко добавлять новые команды в
   проект.

### Паттерны GoF

1. Facade - в пакете facades лежат фасады для CRUD операций над тремя таблицами в схеме бд (Категории, Операции, Счета)
2. Factory - в пакете factories реализован CommandFactory который создает нужную команду
3. Команда + декоратор - в пакете commands лежат реализации всех команд из фасадов, которые запускают методы сервисов.
   В пакете декораторов реализован декоратор для замера времени исполнения команды

## Запуск приложения

1. Нужно поднять базу данных командой `docker-compose up`
2. Запустить Gradle проект